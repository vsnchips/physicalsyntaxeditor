	
function makedrawstack(){	
	//this func walks the ast

	//as it finds types, it opens a rep resentation on a stack.

	//as it steps out of them, it pushes them to a draw list.

	//What matters most is how the object relates to the focus.

	//Representations will be arranged relative to their enclosing scope.

	//Maybe representation promotion may be negotiated through priorities?
		// Its not the node's responsibility to know its relationship to the focus.



		// how is the node traversed in printing? Depth first, or in order?
		children.forEach(child){


		}

}


functionDrawAst(ast,focus){

	-The drawer walks from the focus, and draws the tree, recursing until functionality is blackboxed by focus rules, like running out of room.
	
	-The tree only represents the code within a line.
	Call expressions encapsulate by default.

	-Users may want to promote literals from within their enclosing scope to be interactable from the scopes of their callers as if they are arguments.

	Does it make sense to add extra arguments?
	-Not neccesary, because they are constants, they will be the same in every instance of the function.

	-When you want to click through to mutate an ancapsulated thing, you are changing the master copy.
	There may be an operation added to promote a literal or a variable to an adhoc parameter, with a default argument.

	


	//draw_a_tree(tree, d_region){

	//if leaf
	//if(isLeaf(Tree)){
	drawLeaf(tree);
	 return;
	 }

	//else
	
	 for(int = 0l i < children.length() in tree.childindexmap){
		//tree.childindexmap are ordered. 
		draw_a_tree(tree,drawRegion);
		if()

	}


	}

	function isLeaf(tree){
		switch(tree.type){
		 case 'NumericLiteral':
		 	return true;
		 case 'StringLiteral':
		 	return true;
		 default:
		 	return false;
		 }
		 return false;
	}

}